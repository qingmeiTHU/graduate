\chapter{移动网络中主播端传输优化方案设计}
基于以上的测量和发现，我们重新思考RTMP的设计，从三个不同的层面去定制化这个协议。首先，我们选择合适的关键帧间隔，减少帧之间的依赖性，从而缓解级联的效应的发生。然后，我们通过优化GOP粒度的丢帧策略，去尽可能多的避免丢帧。这两个解决方案是为了解决短时间的带宽降低。最后，我们设计了一个GOP粒度的自适应码率算法，为了对抗长期的带宽衰落。
\section{GOP的最优选择}
\label{sec:design_gop}
关键帧间隔较大的话，当网络有瞬时的带宽下降时，会发生级联效应。但是关键帧间隔过小也会导致过高的压缩比，视频的清晰度会受到损害。因此，最优的GOP是丢帧数和视频质量之间的均衡。

关键帧大小对于丢帧数的影响可以通过控制实验去衡量。我们控制网络环境，多次重复主播推流的过程，保证每一次推的视频相同。在每一次实验中，调节关键帧大小，找出最少丢帧数的关键帧大小。

我们用SSIM作为指标去衡量视频的清晰度，SSIM是通过对比两幅画面的相似度去衡量视频质量。在这里，计算出的SSIM是编码前后两幅画面的相似性。之后，我们多次改变关键帧间隔，找出SSIM在最高值$[95\%-100\%]$之间的最小关键帧间隔。

\section{智能丢帧策略}
在设置关键帧间隔的同时，对于短时间的网络带宽下降，一个更优的丢帧策略也很有必要。我们先假设网络带宽状况已知，找出理论上的最优丢帧策略。之后我们设计一个在线的低复杂度的算法，低复杂度的算法会对移动设备更加友好，且在线算法在实际中可以真实部署。

\subsection{丢帧策略建模}

\begin{table}[tb]
\footnotesize
\centering
\caption{丢帧策略模型所用符号表}
\label{ip_var}
{\setlength{\tabcolsep}{1pt}
\begin{tabular}{|c|c|l|}
\hline
\textbf{符号} & \textbf{类型} & \textbf{含义}                      \\ \hline
$i$               & 编号         & 帧编号                           \\ \hline
$j$               & 编号         & 时间编号                            \\ \hline
$x_{ij}$             & 变量      & 第j个时刻，第i帧是否在队列中\\ \hline
$y_{ij}$             & 变量      & 第j个时刻，第i帧是否已经被发送     \\ \hline
$z_{ij}$             & 变量      & 第j个时刻，第i帧是否已经被丢掉  \\ \hline
$T$               & 常量         &  总决策时长                        \\ \hline
$T_1$             & 常量       & 一个帧能够在队列中留存的时间阈值 \\ \hline
$C_j$              & 常量         & 第j个时刻的网络带宽  \\ \hline
$N$               & 常量         & 关键帧间隔                      \\ \hline
$S$            & 常量         & 每一帧的数据量大小                       \\ \hline
$M_{j}$       & 常量         & 第j个时刻可以发送的最大帧编号 \\ \hline
\end{tabular}}
\end{table}


首先，我们尝试去计算最优丢帧策略可以达到的最佳视频质量。假设视频帧的格式已经固定，全部的网络带宽已知，一定存在一个最优的丢帧策略，在满足带宽和队列时间跨度限制的情况下最大化观众端的观看质量。每个GOP图片组包含三种类型的帧：I帧，P帧和B帧。为了简便，建模时我们忽略B帧，去研究问题的本质。这个问题可以建模成一个整数规划问题，如图所示。所有的符号都定义在表~\ref{ip_var}中。我们将时间分为0-T的时隙，假设第i个时隙产生的帧标号为i。$x_{ij}$，$y_{ij}$，$z_{ij}$是01变量，分别表示视频队列中的帧是在队列中，还是已经被发送出去或者丢弃。

\begin{eqnarray}
% \nonumber % Remove numbering (before each equation)
&\min & \Sigma_i {y_{iT}} \nonumber
\label{obj}
\end{eqnarray}
\ \ subject to
\vspace{-0.2in}
\begin{eqnarray}
% \nonumber % Remove numbering (before each equation)
  && x_{ij}+y_{ij}+z_{ij} = 0, \forall j<i \\
  && x_{ij}+y_{ij}+z_{ij} = 1, \forall j\geq i \\
  && x_{ij} \geq x_{i,j+1}, \forall j\geq i \\
  && y_{ij} \leq y_{i,j+1}, \forall j\geq i \\
  && z_{ij} \leq z_{i,j+1}, \forall j\geq i \\
  && y_{ij} = \max\{1,{1-z_{i,j-1}}\}, \forall j, i \leq M_{j} \\
  && y_{ij}+z_{ij} = 1 ,\forall j>i+T_2 \\
  && y_{i+1,T} \geq y_{iT}, \forall i \not\equiv N-1 (\text{mod}N)
\end{eqnarray}

\textbf{帧留存性约束} 第i个时刻产生标号为i的帧。之后，第i个帧要么留在视频队列中，或者被发送出去，或者被丢掉。如果帧已经从视频队列中移除，那么之后永远不会再进入队列。一个帧被发送或者丢掉后，它的状态就永远变成了已发送或者被丢弃。

\textbf{带宽约束} 最优的发送策略$y_{ij}$，也是一个重要且有趣的问题。然而，在本文中，我们假设主播端在满足网络容量约束的条件下，每次尽可能多的发送内容。除此之外，可以被发送的帧必须在队列里。有了这些约束，每个时隙最大的可发送的帧编号$M_j$可以通过下面的等式来计算。
\begin{align}
M_j = argmax \Sigma_k (1-y_{k,j-1})(1-z_{k,j-1}) \leq C_{j}
\end{align}

\textbf{及时性约束} 如果帧产生之后的$T1$秒内发送出去，就能符合及时性的要求。所以说，当一个帧产生$T1$秒之后，要么被发送出去，要么就是被丢弃。

\textbf{解码约束} 成功传输的帧必须要可以解码，否则，这也是对带宽的一种浪费，并没有充分利用带宽。I帧始终可以解码，P帧只有在前面的I帧或者P帧存在的情况下才能正常解码。

\textbf{优化目标} 整数规划的目标函数是去最大化传输的帧数。与之前的研究相比，我们的整数规划模型考虑了及时性和是否能解码等约束，更加符合个人交互直播的场景。

\subsection{启发式算法}
整数规划可以求得离线最优，然而实际情况中我们并不能提前掌握长期的带宽状况。另外，整数规划的时间复杂度对于移动设备来说太高，不能负担。因此，整数规划在实际情况中不能使用，急需一个在线的丢帧策略。

考虑到两个或者多个GOP同时存在在视频队列里的情况，我们提出了改进版的丢帧算法，GreedyDrop，如算法1所示。不同于默认算法将视频队列中所有的P帧都丢弃，GreedyDrop仅仅丢掉旧的GOP中的所有P帧。 因此较新产生的GOP的帧被保留了下来，我们的算法至少减少了一个GOP数量的帧丢失。

\section{自适应码率}
\subsection{动态码率建模}
为了进一步解决长时间的带宽抖动问题，我们采用动态自适应码率的方式。首先，我们还是先尝试计算出通过调整码率能达到的最佳质量；之后，为移动设备设计一个在线可用的算法。

\begin{table}[tb]
\centering
\caption{动态码率符号表}
\label{vbr_vbr}
{\setlength{\tabcolsep}{1pt}
\begin{tabular}{|c|c|l|}
\hline
\textbf{符号} & \textbf{类型} & \textbf{含义}                      \\ \hline
$j$               & 编号         & 帧标号                            \\ \hline
$R_j$             & 变量      & 第j帧的码率 \\ \hline
$N_j$             & 变量      & 第j个时刻的GOP组数     \\ \hline
$D_j$             & 变量      & 第j个时刻是否发生丢帧  \\ \hline
$S_j$             & 变量   & 第j个时刻发送出的GOP组数 \\ \hline
$C_j$              & 变量         & 第j个时刻的网络带宽           \\ \hline
$T_k^j$               & 变量         & 第j时刻第k个GOP剩余的时间  \\ \hline
$R_k^j$            & 变量         & 第j个时刻第k个GOP的码率  \\ \hline
$Drop_j$       & 变量 & 第j个时刻是否发生丢帧 \\ \hline
$T$               & 变量         & 总决策时长                       \\ \hline
$T_1$               &变量          & 一个帧能够在队列中留存的时间阈值 \\
\hline\end{tabular}}
\end{table}

我们引入了一个变量$R_i$，$R_i$表现第i帧所对应的码率。使用GreedyDrop作为我们的丢帧策略，效益函数可以建模成式10。等式中的第一项是码率效益，第二项代表码率切换损失，最后一项等于丢帧损失。表三给出了模型相关的所有变量，变量$\alpha$和$\beta$对应码率切换损失和丢帧损失的系数。$sgn$是修正版的符号函数，当变量大于0时，函数值等于1；否则函数值等于0。$mod$是取余函数。

\textbf{码率约束} 约束条件（1）规定一个GOP内的码率必须相同。

\textbf{带宽约束} 等式（2）计算在有限带宽下最多能够发送的GOP组数。

\textbf{及时性约束} 约束条件（3）判断队列现在的时间跨度是否超过队列的限制，（4）给出在第j个时隙丢弃的帧的数目。

\textbf{状态转移方程} 约束条件（7-11）是队列中所剩GOP的码率和剩余时间的转移方程。等式（6）描述了第j+1个时隙的GOP组数，等式（6）的最后两项 $1-mod(j,M)$ 表示第j个帧是否是关键帧。

最优的解决方案很难求解。假设对于每个GOP组，主播端可以任意选择M个码率，那么对于T个GOP组，计算复杂度等于$M^T$，达到了指数复杂度。

\subsection{启发式动态码率算法}
指数复杂度的问题很难在有限的时间内求得答案。除此之外，离线最优算法需要基于对未来带宽的全部了解。这种长时间的带宽预测很难做到精确。一个直觉的想法是根据带宽改变码率。而且，队列中的剩余数据量大小也是选择码率的有效信息。我们提出了启发式动态码率算法，简称GVBR。根据GVBR算法，在第j个时刻，主播端执行下面两个关键步骤。$\eta$是有关丢帧和码率的系数。

\begin{description}
  \item[带宽估计] 根据Festive和MPC，调和平均值是估计未来带宽的有效方法。越精确的码率估计，我们的算法性能会越好。
  \item[码率选择] 为了避免频繁的丢包，选择一个合适的码率尤为重要。已知未来的带宽$C_j$和队列的数据量大小$Rest$，启发式算法总是选择比$(C_j-Rest)/\eta$低的最高码率。
\end{description}

GVBR是我们提出的一整套改善主播端质量的解决方案，包含GOP层面和帧层面。
